"use strict";(self.webpackChunk_arizeai_point_cloud=self.webpackChunk_arizeai_point_cloud||[]).push([[712],{"./stories/Tooltip.stories.tsx":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Default:()=>Default,__namedExportsOrder:()=>__namedExportsOrder,default:()=>Tooltip_stories});var react=__webpack_require__("./node_modules/react/index.js"),components=__webpack_require__("./stories/components/index.tsx"),src=__webpack_require__("./src/index.tsx"),esm_extends=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/extends.js"),client=__webpack_require__("./node_modules/react-dom/client.js"),three_module=__webpack_require__("./node_modules/three/build/three.module.js"),index_76c68185_esm=__webpack_require__("./node_modules/@react-three/fiber/dist/index-76c68185.esm.js");const v1=new three_module.Vector3,v2=new three_module.Vector3,v3=new three_module.Vector3,v4=new three_module.Vector2;function defaultCalculatePosition(el,camera,size){const objectPos=v1.setFromMatrixPosition(el.matrixWorld);objectPos.project(camera);const widthHalf=size.width/2,heightHalf=size.height/2;return[objectPos.x*widthHalf+widthHalf,-objectPos.y*heightHalf+heightHalf]}const epsilon=value=>Math.abs(value)<1e-10?0:value;function getCSSMatrix(matrix,multipliers,prepend=""){let matrix3d="matrix3d(";for(let i=0;16!==i;i++)matrix3d+=epsilon(multipliers[i]*matrix.elements[i])+(15!==i?",":")");return prepend+matrix3d}const getCameraCSSMatrix=(multipliers=[1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1],matrix=>getCSSMatrix(matrix,multipliers));var multipliers;const getObjectCSSMatrix=(matrix,factor)=>{return getCSSMatrix(matrix,[1/(f=factor),1/f,1/f,1,-1/f,-1/f,-1/f,-1,1/f,1/f,1/f,1,1,1,1,1],"translate(-50%,-50%)");var f};const Html=react.forwardRef((({children,eps=.001,style,className,prepend,center,fullscreen,portal,distanceFactor,sprite=!1,transform=!1,occlude,onOcclude,castShadow,receiveShadow,material,geometry,zIndexRange=[16777271,0],calculatePosition=defaultCalculatePosition,as="div",wrapperClass,pointerEvents="auto",...props},ref)=>{const{gl,camera,scene,size,raycaster,events,viewport}=(0,index_76c68185_esm.z)(),[el]=react.useState((()=>document.createElement(as))),root=react.useRef(),group=react.useRef(null),oldZoom=react.useRef(0),oldPosition=react.useRef([0,0]),transformOuterRef=react.useRef(null),transformInnerRef=react.useRef(null),target=(null==portal?void 0:portal.current)||events.connected||gl.domElement.parentNode,occlusionMeshRef=react.useRef(null),isMeshSizeSet=react.useRef(!1),isRayCastOcclusion=react.useMemo((()=>occlude&&"blending"!==occlude||Array.isArray(occlude)&&occlude.length&&function isRefObject(ref){return ref&&"object"==typeof ref&&"current"in ref}(occlude[0])),[occlude]);react.useLayoutEffect((()=>{const el=gl.domElement;occlude&&"blending"===occlude?(el.style.zIndex=`${Math.floor(zIndexRange[0]/2)}`,el.style.position="absolute",el.style.pointerEvents="none"):(el.style.zIndex=null,el.style.position=null,el.style.pointerEvents=null)}),[occlude]),react.useLayoutEffect((()=>{if(group.current){const currentRoot=root.current=client.createRoot(el);if(scene.updateMatrixWorld(),transform)el.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const vec=calculatePosition(group.current,camera,size);el.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${vec[0]}px,${vec[1]}px,0);transform-origin:0 0;`}return target&&(prepend?target.prepend(el):target.appendChild(el)),()=>{target&&target.removeChild(el),currentRoot.unmount()}}}),[target,transform]),react.useLayoutEffect((()=>{wrapperClass&&(el.className=wrapperClass)}),[wrapperClass]);const styles=react.useMemo((()=>transform?{position:"absolute",top:0,left:0,width:size.width,height:size.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:center?"translate3d(-50%,-50%,0)":"none",...fullscreen&&{top:-size.height/2,left:-size.width/2,width:size.width,height:size.height},...style}),[style,center,fullscreen,size,transform]),transformInnerStyles=react.useMemo((()=>({position:"absolute",pointerEvents})),[pointerEvents]);react.useLayoutEffect((()=>{var _root$current,_root$current2;(isMeshSizeSet.current=!1,transform)?null==(_root$current=root.current)||_root$current.render(react.createElement("div",{ref:transformOuterRef,style:styles},react.createElement("div",{ref:transformInnerRef,style:transformInnerStyles},react.createElement("div",{ref,className,style,children})))):null==(_root$current2=root.current)||_root$current2.render(react.createElement("div",{ref,style:styles,className,children}))}));const visible=react.useRef(!0);(0,index_76c68185_esm.A)((gl=>{if(group.current){camera.updateMatrixWorld(),group.current.updateWorldMatrix(!0,!1);const vec=transform?oldPosition.current:calculatePosition(group.current,camera,size);if(transform||Math.abs(oldZoom.current-camera.zoom)>eps||Math.abs(oldPosition.current[0]-vec[0])>eps||Math.abs(oldPosition.current[1]-vec[1])>eps){const isBehindCamera=function isObjectBehindCamera(el,camera){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),deltaCamObj=objectPos.sub(cameraPos),camDir=camera.getWorldDirection(v3);return deltaCamObj.angleTo(camDir)>Math.PI/2}(group.current,camera);let raytraceTarget=!1;isRayCastOcclusion&&(Array.isArray(occlude)?raytraceTarget=occlude.map((item=>item.current)):"blending"!==occlude&&(raytraceTarget=[scene]));const previouslyVisible=visible.current;if(raytraceTarget){const isvisible=function isObjectVisible(el,camera,raycaster,occlude){const elPos=v1.setFromMatrixPosition(el.matrixWorld),screenPos=elPos.clone();screenPos.project(camera),v4.set(screenPos.x,screenPos.y),raycaster.setFromCamera(v4,camera);const intersects=raycaster.intersectObjects(occlude,!0);if(intersects.length){const intersectionDistance=intersects[0].distance;return elPos.distanceTo(raycaster.ray.origin)<intersectionDistance}return!0}(group.current,camera,raycaster,raytraceTarget);visible.current=isvisible&&!isBehindCamera}else visible.current=!isBehindCamera;previouslyVisible!==visible.current&&(onOcclude?onOcclude(!visible.current):el.style.display=visible.current?"block":"none");const halfRange=Math.floor(zIndexRange[0]/2),zRange=occlude?isRayCastOcclusion?[zIndexRange[0],halfRange]:[halfRange-1,0]:zIndexRange;if(el.style.zIndex=`${function objectZIndex(el,camera,zIndexRange){if(camera instanceof three_module.PerspectiveCamera||camera instanceof three_module.OrthographicCamera){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),dist=objectPos.distanceTo(cameraPos),A=(zIndexRange[1]-zIndexRange[0])/(camera.far-camera.near),B=zIndexRange[1]-A*camera.far;return Math.round(A*dist+B)}}(group.current,camera,zRange)}`,transform){const[widthHalf,heightHalf]=[size.width/2,size.height/2],fov=camera.projectionMatrix.elements[5]*heightHalf,{isOrthographicCamera,top,left,bottom,right}=camera,cameraMatrix=getCameraCSSMatrix(camera.matrixWorldInverse),cameraTransform=isOrthographicCamera?`scale(${fov})translate(${epsilon(-(right+left)/2)}px,${epsilon((top+bottom)/2)}px)`:`translateZ(${fov}px)`;let matrix=group.current.matrixWorld;sprite&&(matrix=camera.matrixWorldInverse.clone().transpose().copyPosition(matrix).scale(group.current.scale),matrix.elements[3]=matrix.elements[7]=matrix.elements[11]=0,matrix.elements[15]=1),el.style.width=size.width+"px",el.style.height=size.height+"px",el.style.perspective=isOrthographicCamera?"":`${fov}px`,transformOuterRef.current&&transformInnerRef.current&&(transformOuterRef.current.style.transform=`${cameraTransform}${cameraMatrix}translate(${widthHalf}px,${heightHalf}px)`,transformInnerRef.current.style.transform=getObjectCSSMatrix(matrix,1/((distanceFactor||10)/400)))}else{const scale=void 0===distanceFactor?1:function objectScale(el,camera){if(camera instanceof three_module.OrthographicCamera)return camera.zoom;if(camera instanceof three_module.PerspectiveCamera){const objectPos=v1.setFromMatrixPosition(el.matrixWorld),cameraPos=v2.setFromMatrixPosition(camera.matrixWorld),vFOV=camera.fov*Math.PI/180,dist=objectPos.distanceTo(cameraPos);return 1/(2*Math.tan(vFOV/2)*dist)}return 1}(group.current,camera)*distanceFactor;el.style.transform=`translate3d(${vec[0]}px,${vec[1]}px,0) scale(${scale})`}oldPosition.current=vec,oldZoom.current=camera.zoom}}if(!isRayCastOcclusion&&occlusionMeshRef.current&&!isMeshSizeSet.current)if(transform){if(transformOuterRef.current){const el=transformOuterRef.current.children[0];if(null!=el&&el.clientWidth&&null!=el&&el.clientHeight){const{isOrthographicCamera}=camera;if(isOrthographicCamera||geometry)props.scale&&(Array.isArray(props.scale)?props.scale instanceof three_module.Vector3?occlusionMeshRef.current.scale.copy(props.scale.clone().divideScalar(1)):occlusionMeshRef.current.scale.set(1/props.scale[0],1/props.scale[1],1/props.scale[2]):occlusionMeshRef.current.scale.setScalar(1/props.scale));else{const ratio=(distanceFactor||10)/400,w=el.clientWidth*ratio,h=el.clientHeight*ratio;occlusionMeshRef.current.scale.set(w,h,1)}isMeshSizeSet.current=!0}}}else{const ele=el.children[0];if(null!=ele&&ele.clientWidth&&null!=ele&&ele.clientHeight){const ratio=1/viewport.factor,w=ele.clientWidth*ratio,h=ele.clientHeight*ratio;occlusionMeshRef.current.scale.set(w,h,1),isMeshSizeSet.current=!0}occlusionMeshRef.current.lookAt(gl.camera.position)}}));const shaders=react.useMemo((()=>({vertexShader:transform?void 0:'\n          /*\n            This shader is from the THREE\'s SpriteMaterial.\n            We need to turn the backing plane into a Sprite\n            (make it always face the camera) if "transfrom"\n            is false.\n          */\n          #include <common>\n\n          void main() {\n            vec2 center = vec2(0., 1.);\n            float rotation = 0.0;\n\n            // This is somewhat arbitrary, but it seems to work well\n            // Need to figure out how to derive this dynamically if it even matters\n            float size = 0.03;\n\n            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n            vec2 scale;\n            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\n            bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n            if ( isPerspective ) scale *= - mvPosition.z;\n\n            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;\n            vec2 rotatedPosition;\n            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n            mvPosition.xy += rotatedPosition;\n\n            gl_Position = projectionMatrix * mvPosition;\n          }\n      ',fragmentShader:"\n        void main() {\n          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      "})),[transform]);return react.createElement("group",(0,esm_extends.A)({},props,{ref:group}),occlude&&!isRayCastOcclusion&&react.createElement("mesh",{castShadow,receiveShadow,ref:occlusionMeshRef},geometry||react.createElement("planeGeometry",null),material||react.createElement("shaderMaterial",{side:three_module.DoubleSide,vertexShader:shaders.vertexShader,fragmentShader:shaders.fragmentShader})))}));function _slicedToArray(arr,i){return function _arrayWithHoles(arr){if(Array.isArray(arr))return arr}(arr)||function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}(arr,i)||_unsupportedIterableToArray(arr,i)||function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _toConsumableArray(arr){return function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}(arr)||function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}(arr)||_unsupportedIterableToArray(arr)||function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}var data=__webpack_require__("./stories/data/point-cloud-3d.json");const Tooltip_stories={title:"Tooltip"};function Default(){var bounds=react.useMemo((function(){return(0,src.dV)(_toConsumableArray(data.map((function(d){return d.position}))))}),[]),_useState2=_slicedToArray((0,react.useState)(null),2),selectedPoint=_useState2[0],setSelectedPoint=_useState2[1];return react.createElement(components.mc,{showToolbar:!1},react.createElement(src.WU,{camera:{zoom:1,up:[0,0,1]}},react.createElement("ambientLight",{intensity:.5}),react.createElement("pointLight",{position:[0,0,10]}),react.createElement(src.GP,null),react.createElement(src.Rm,{bounds},react.createElement(src.Y5,{size:bounds.maxX-bounds.minX}),react.createElement(src.ON,{data,pointProps:{color:"limegreen"},onPointHovered:function onPointHovered(point){(0,react.startTransition)((function(){setSelectedPoint(point)}))},onPointerLeave:function onPointerLeave(){(0,react.startTransition)((function(){setSelectedPoint(null)}))}})),selectedPoint?react.createElement(Html,{position:selectedPoint.position},react.createElement("div",{style:{color:"white",padding:"10px 10px"}},react.createElement("section",{style:{background:"gray",borderRadius:"4px"}},selectedPoint.metaData.uuid))):null))}const __namedExportsOrder=["Default"]}}]);